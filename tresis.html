<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Spatial Microsimulation with R</title>
  <meta name="description" content="Learn what how to model systems at individual to areal levels and discover how to do spatial microsimulation at in a reproducible manner using high performance, open source software.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Spatial Microsimulation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://spatial-microsim-book.robinlovelace.net" />
  <meta property="og:image" content="https://spatial-microsim-book.robinlovelace.netfigures/cover-image.jpg" />
  <meta property="og:description" content="Learn what how to model systems at individual to areal levels and discover how to do spatial microsimulation at in a reproducible manner using high performance, open source software." />
  <meta name="github-repo" content="Robinlovelace/spatial-microsim-book" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Spatial Microsimulation with R" />
  <meta name="twitter:site" content="@robinlovelace" />
  <meta name="twitter:description" content="Learn what how to model systems at individual to areal levels and discover how to do spatial microsimulation at in a reproducible manner using high performance, open source software." />
  <meta name="twitter:image" content="https://spatial-microsim-book.robinlovelace.netfigures/cover-image.jpg" />

<meta name="author" content="Robin Lovelace and Morgane Dumont">


<meta name="date" content="2017-12-14">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="ha.html">
<link rel="next" href="ABM.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reference"><i class="fa fa-check"></i>Reference</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#who-this-book-is-for-and-how-to-use-it"><i class="fa fa-check"></i><b>1.1</b> Who this book is for and how to use it</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#motivations"><i class="fa fa-check"></i><b>1.2</b> Motivations</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#a-definition-of-spatial-microsimulation"><i class="fa fa-check"></i><b>1.3</b> A definition of spatial microsimulation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#learning-by-doing"><i class="fa fa-check"></i><b>1.4</b> Learning by doing</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#whyR"><i class="fa fa-check"></i><b>1.5</b> Why spatial microsimulation with R?</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#learningR"><i class="fa fa-check"></i><b>1.6</b> Learning the R language</a></li>
<li class="chapter" data-level="1.7" data-path="intro.html"><a href="intro.html#typographic"><i class="fa fa-check"></i><b>1.7</b> Typographic conventions</a></li>
<li class="chapter" data-level="1.8" data-path="intro.html"><a href="intro.html#overview"><i class="fa fa-check"></i><b>1.8</b> An overview of the book</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="SimpleWorld.html"><a href="SimpleWorld.html"><i class="fa fa-check"></i><b>2</b> SimpleWorld: A worked example of spatial microsimulation</a><ul>
<li class="chapter" data-level="2.1" data-path="SimpleWorld.html"><a href="SimpleWorld.html#rstudioUpSpeed"><i class="fa fa-check"></i><b>2.1</b> Getting setup with the RStudio environment</a><ul>
<li class="chapter" data-level="2.1.1" data-path="SimpleWorld.html"><a href="SimpleWorld.html#installing-r"><i class="fa fa-check"></i><b>2.1.1</b> Installing R</a></li>
<li class="chapter" data-level="2.1.2" data-path="SimpleWorld.html"><a href="SimpleWorld.html#rstudio"><i class="fa fa-check"></i><b>2.1.2</b> RStudio</a></li>
<li class="chapter" data-level="2.1.3" data-path="SimpleWorld.html"><a href="SimpleWorld.html#projects"><i class="fa fa-check"></i><b>2.1.3</b> Projects</a></li>
<li class="chapter" data-level="2.1.4" data-path="SimpleWorld.html"><a href="SimpleWorld.html#downloading-data-for-the-book"><i class="fa fa-check"></i><b>2.1.4</b> Downloading data for the book</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="SimpleWorld.html"><a href="SimpleWorld.html#SimpleWorldData"><i class="fa fa-check"></i><b>2.2</b> SimpleWorld data</a></li>
<li class="chapter" data-level="2.3" data-path="SimpleWorld.html"><a href="SimpleWorld.html#weight-matrix"><i class="fa fa-check"></i><b>2.3</b> Generating a weight matrix</a></li>
<li class="chapter" data-level="2.4" data-path="SimpleWorld.html"><a href="SimpleWorld.html#spatial-microdata"><i class="fa fa-check"></i><b>2.4</b> Spatial microdata</a></li>
<li class="chapter" data-level="2.5" data-path="SimpleWorld.html"><a href="SimpleWorld.html#SimpleWorldContext"><i class="fa fa-check"></i><b>2.5</b> SimpleWorld in context</a></li>
<li class="chapter" data-level="2.6" data-path="SimpleWorld.html"><a href="SimpleWorld.html#chapter-summary"><i class="fa fa-check"></i><b>2.6</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="what-is.html"><a href="what-is.html"><i class="fa fa-check"></i><b>3</b> What is spatial microsimulation?</a><ul>
<li class="chapter" data-level="3.1" data-path="what-is.html"><a href="what-is.html#terminology"><i class="fa fa-check"></i><b>3.1</b> Terminology</a><ul>
<li class="chapter" data-level="3.1.1" data-path="what-is.html"><a href="what-is.html#SimCity"><i class="fa fa-check"></i><b>3.1.1</b> Spatial microsimulation as SimCity</a></li>
<li class="chapter" data-level="3.1.2" data-path="what-is.html"><a href="what-is.html#meth-approach"><i class="fa fa-check"></i><b>3.1.2</b> Spatial microsimulation: method or approach?</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="what-is.html"><a href="what-is.html#is-not"><i class="fa fa-check"></i><b>3.2</b> What spatial microsimulation is not</a></li>
<li class="chapter" data-level="3.3" data-path="what-is.html"><a href="what-is.html#applications"><i class="fa fa-check"></i><b>3.3</b> Applications</a><ul>
<li class="chapter" data-level="3.3.1" data-path="what-is.html"><a href="what-is.html#health-applications"><i class="fa fa-check"></i><b>3.3.1</b> Health applications</a></li>
<li class="chapter" data-level="3.3.2" data-path="what-is.html"><a href="what-is.html#economic-policy-evaluation"><i class="fa fa-check"></i><b>3.3.2</b> Economic policy evaluation</a></li>
<li class="chapter" data-level="3.3.3" data-path="what-is.html"><a href="what-is.html#transport"><i class="fa fa-check"></i><b>3.3.3</b> Transport</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="what-is.html"><a href="what-is.html#assumptions"><i class="fa fa-check"></i><b>3.4</b> Assumptions</a></li>
<li class="chapter" data-level="3.5" data-path="what-is.html"><a href="what-is.html#chapter-summary-1"><i class="fa fa-check"></i><b>3.5</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="data-prep.html"><a href="data-prep.html"><i class="fa fa-check"></i><b>4</b> Data preparation</a><ul>
<li class="chapter" data-level="4.1" data-path="data-prep.html"><a href="data-prep.html#accessing"><i class="fa fa-check"></i><b>4.1</b> Accessing the input data</a></li>
<li class="chapter" data-level="4.2" data-path="data-prep.html"><a href="data-prep.html#Selecting"><i class="fa fa-check"></i><b>4.2</b> Target and constraint variables</a></li>
<li class="chapter" data-level="4.3" data-path="data-prep.html"><a href="data-prep.html#Loading"><i class="fa fa-check"></i><b>4.3</b> Loading input data</a></li>
<li class="chapter" data-level="4.4" data-path="data-prep.html"><a href="data-prep.html#subsetting-prep"><i class="fa fa-check"></i><b>4.4</b> Subsetting to remove excess information</a></li>
<li class="chapter" data-level="4.5" data-path="data-prep.html"><a href="data-prep.html#re-categorise"><i class="fa fa-check"></i><b>4.5</b> Re-categorising individual level variables</a></li>
<li class="chapter" data-level="4.6" data-path="data-prep.html"><a href="data-prep.html#matching"><i class="fa fa-check"></i><b>4.6</b> Matching individual and aggregate level data names</a></li>
<li class="chapter" data-level="4.7" data-path="data-prep.html"><a href="data-prep.html#flattening"><i class="fa fa-check"></i><b>4.7</b> ‘Flattening’ the individual level data</a></li>
<li class="chapter" data-level="4.8" data-path="data-prep.html"><a href="data-prep.html#chapter-summary-2"><i class="fa fa-check"></i><b>4.8</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="smsimr.html"><a href="smsimr.html"><i class="fa fa-check"></i><b>5</b> Population synthesis</a><ul>
<li class="chapter" data-level="5.1" data-path="smsimr.html"><a href="smsimr.html#weighting"><i class="fa fa-check"></i><b>5.1</b> Weighting algorithms</a></li>
<li class="chapter" data-level="5.2" data-path="smsimr.html"><a href="smsimr.html#iterative-proportional-fitting"><i class="fa fa-check"></i><b>5.2</b> Iterative Proportional Fitting</a><ul>
<li class="chapter" data-level="5.2.1" data-path="smsimr.html"><a href="smsimr.html#ipftheory"><i class="fa fa-check"></i><b>5.2.1</b> IPF in theory</a></li>
<li class="chapter" data-level="5.2.2" data-path="smsimr.html"><a href="smsimr.html#ipfinr"><i class="fa fa-check"></i><b>5.2.2</b> IPF in R</a></li>
<li class="chapter" data-level="5.2.3" data-path="smsimr.html"><a href="smsimr.html#ipfp"><i class="fa fa-check"></i><b>5.2.3</b> IPF with <strong>ipfp</strong></a></li>
<li class="chapter" data-level="5.2.4" data-path="smsimr.html"><a href="smsimr.html#mipfp"><i class="fa fa-check"></i><b>5.2.4</b> IPF with <strong>mipfp</strong></a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="smsimr.html"><a href="smsimr.html#sintegerisation"><i class="fa fa-check"></i><b>5.3</b> Integerisation</a><ul>
<li class="chapter" data-level="5.3.1" data-path="smsimr.html"><a href="smsimr.html#concept-of-integerisation"><i class="fa fa-check"></i><b>5.3.1</b> Concept of integerisation</a></li>
<li class="chapter" data-level="5.3.2" data-path="smsimr.html"><a href="smsimr.html#example-of-integerisation"><i class="fa fa-check"></i><b>5.3.2</b> Example of integerisation</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="smsimr.html"><a href="smsimr.html#expansion"><i class="fa fa-check"></i><b>5.4</b> Expansion</a><ul>
<li class="chapter" data-level="5.4.1" data-path="smsimr.html"><a href="smsimr.html#weights-per-individual"><i class="fa fa-check"></i><b>5.4.1</b> Weights per individual</a></li>
<li class="chapter" data-level="5.4.2" data-path="smsimr.html"><a href="smsimr.html#weightpc"><i class="fa fa-check"></i><b>5.4.2</b> Weights per category</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="smsimr.html"><a href="smsimr.html#integerisation-and-expansion"><i class="fa fa-check"></i><b>5.5</b> Integerisation and expansion</a></li>
<li class="chapter" data-level="5.6" data-path="smsimr.html"><a href="smsimr.html#compareipf"><i class="fa fa-check"></i><b>5.6</b> Comparing <strong>ipfp</strong> with <strong>mipfp</strong></a><ul>
<li class="chapter" data-level="5.6.1" data-path="smsimr.html"><a href="smsimr.html#comparing-the-methods"><i class="fa fa-check"></i><b>5.6.1</b> Comparing the methods</a></li>
<li class="chapter" data-level="5.6.2" data-path="smsimr.html"><a href="smsimr.html#comparing-the-weights-for-simpleworld"><i class="fa fa-check"></i><b>5.6.2</b> Comparing the weights for SimpleWorld</a></li>
<li class="chapter" data-level="5.6.3" data-path="smsimr.html"><a href="smsimr.html#comparing-the-results-for-simpleworld"><i class="fa fa-check"></i><b>5.6.3</b> Comparing the results for SimpleWorld</a></li>
<li class="chapter" data-level="5.6.4" data-path="smsimr.html"><a href="smsimr.html#speed-comparisons"><i class="fa fa-check"></i><b>5.6.4</b> Speed comparisons</a></li>
</ul></li>
<li class="chapter" data-level="5.7" data-path="smsimr.html"><a href="smsimr.html#chapter-summary-3"><i class="fa fa-check"></i><b>5.7</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html"><i class="fa fa-check"></i><b>6</b> Alternative approaches to population synthesis</a><ul>
<li class="chapter" data-level="6.1" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#GREGWT"><i class="fa fa-check"></i><b>6.1</b> GREGWT</a></li>
<li class="chapter" data-level="6.2" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#asOptim"><i class="fa fa-check"></i><b>6.2</b> Population synthesis as an optimization problem</a><ul>
<li class="chapter" data-level="6.2.1" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#reweighting-with-optim-and-gensa"><i class="fa fa-check"></i><b>6.2.1</b> Reweighting with optim and GenSA</a></li>
<li class="chapter" data-level="6.2.2" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#combinatorial-optimisation"><i class="fa fa-check"></i><b>6.2.2</b> Combinatorial optimisation</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#SimPop"><i class="fa fa-check"></i><b>6.3</b> simPop</a></li>
<li class="chapter" data-level="6.4" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#UDST"><i class="fa fa-check"></i><b>6.4</b> The Urban Data Science Toolkit (UDST)</a></li>
<li class="chapter" data-level="6.5" data-path="alternative-reweighting.html"><a href="alternative-reweighting.html#chapter-summary-4"><i class="fa fa-check"></i><b>6.5</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="CakeMap.html"><a href="CakeMap.html"><i class="fa fa-check"></i><b>7</b> Spatial microsimulation in the wild</a><ul>
<li class="chapter" data-level="7.1" data-path="CakeMap.html"><a href="CakeMap.html#CakeMapConVar"><i class="fa fa-check"></i><b>7.1</b> Selection of constraint variables</a></li>
<li class="chapter" data-level="7.2" data-path="CakeMap.html"><a href="CakeMap.html#CakePrep"><i class="fa fa-check"></i><b>7.2</b> Preparing the input data</a></li>
<li class="chapter" data-level="7.3" data-path="CakeMap.html"><a href="CakeMap.html#CakeMapIPFP"><i class="fa fa-check"></i><b>7.3</b> Using the <code>ipfp</code> package</a><ul>
<li class="chapter" data-level="7.3.1" data-path="CakeMap.html"><a href="CakeMap.html#CakeIPF"><i class="fa fa-check"></i><b>7.3.1</b> Performing IPF on CakeMap data</a></li>
<li class="chapter" data-level="7.3.2" data-path="CakeMap.html"><a href="CakeMap.html#CakeINT"><i class="fa fa-check"></i><b>7.3.2</b> Integerisation</a></li>
</ul></li>
<li class="chapter" data-level="7.4" data-path="CakeMap.html"><a href="CakeMap.html#CakeMIPF"><i class="fa fa-check"></i><b>7.4</b> Using the <code>mipfp</code> package</a><ul>
<li class="chapter" data-level="7.4.1" data-path="CakeMap.html"><a href="CakeMap.html#CakeIPF"><i class="fa fa-check"></i><b>7.4.1</b> Performing IPF on CakeMap data</a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="CakeMap.html"><a href="CakeMap.html#CompareMeth"><i class="fa fa-check"></i><b>7.5</b> Comparing methods of reweighting large datasets</a><ul>
<li class="chapter" data-level="7.5.1" data-path="CakeMap.html"><a href="CakeMap.html#comparison-of-results"><i class="fa fa-check"></i><b>7.5.1</b> Comparison of results</a></li>
<li class="chapter" data-level="7.5.2" data-path="CakeMap.html"><a href="CakeMap.html#comparison-of-times"><i class="fa fa-check"></i><b>7.5.2</b> Comparison of times</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="CakeMap.html"><a href="CakeMap.html#chapter-summary-5"><i class="fa fa-check"></i><b>7.6</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="svalidation.html"><a href="svalidation.html"><i class="fa fa-check"></i><b>8</b> Model checking and evaluation</a><ul>
<li class="chapter" data-level="8.1" data-path="svalidation.html"><a href="svalidation.html#Internal"><i class="fa fa-check"></i><b>8.1</b> Internal validation</a><ul>
<li class="chapter" data-level="8.1.1" data-path="svalidation.html"><a href="svalidation.html#pearsons-r"><i class="fa fa-check"></i><b>8.1.1</b> Pearson’s <em>r</em></a></li>
<li class="chapter" data-level="8.1.2" data-path="svalidation.html"><a href="svalidation.html#absolute-error-measures"><i class="fa fa-check"></i><b>8.1.2</b> Absolute error measures</a></li>
<li class="chapter" data-level="8.1.3" data-path="svalidation.html"><a href="svalidation.html#root-mean-squared-error"><i class="fa fa-check"></i><b>8.1.3</b> Root mean squared error</a></li>
<li class="chapter" data-level="8.1.4" data-path="svalidation.html"><a href="svalidation.html#chi-squared"><i class="fa fa-check"></i><b>8.1.4</b> Chi-squared</a></li>
<li class="chapter" data-level="8.1.5" data-path="svalidation.html"><a href="svalidation.html#which-test-to-use"><i class="fa fa-check"></i><b>8.1.5</b> Which test to use?</a></li>
<li class="chapter" data-level="8.1.6" data-path="svalidation.html"><a href="svalidation.html#internal-validation-of-cakemap"><i class="fa fa-check"></i><b>8.1.6</b> Internal validation of CakeMap</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="svalidation.html"><a href="svalidation.html#empty-cells"><i class="fa fa-check"></i><b>8.2</b> Empty cells</a></li>
<li class="chapter" data-level="8.3" data-path="svalidation.html"><a href="svalidation.html#External"><i class="fa fa-check"></i><b>8.3</b> External validation</a></li>
<li class="chapter" data-level="8.4" data-path="svalidation.html"><a href="svalidation.html#chapter-summary-6"><i class="fa fa-check"></i><b>8.4</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="nomicrodata.html"><a href="nomicrodata.html"><i class="fa fa-check"></i><b>9</b> Population synthesis without microdata</a><ul>
<li class="chapter" data-level="9.1" data-path="nomicrodata.html"><a href="nomicrodata.html#CrossGlobLocalMarg"><i class="fa fa-check"></i><b>9.1</b> Global cross-tables and local marginal distributions</a></li>
<li class="chapter" data-level="9.2" data-path="nomicrodata.html"><a href="nomicrodata.html#twoLevelData"><i class="fa fa-check"></i><b>9.2</b> Two level aggregated data</a></li>
<li class="chapter" data-level="9.3" data-path="nomicrodata.html"><a href="nomicrodata.html#chapter-summary-7"><i class="fa fa-check"></i><b>9.3</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ha.html"><a href="ha.html"><i class="fa fa-check"></i><b>10</b> Household allocation</a><ul>
<li class="chapter" data-level="10.1" data-path="ha.html"><a href="ha.html#IndData"><i class="fa fa-check"></i><b>10.1</b> Independent data (individuals and households)</a><ul>
<li class="chapter" data-level="10.1.1" data-path="ha.html"><a href="ha.html#household-type-selection"><i class="fa fa-check"></i><b>10.1.1</b> Household type selection</a></li>
<li class="chapter" data-level="10.1.2" data-path="ha.html"><a href="ha.html#constituent-members-selection"><i class="fa fa-check"></i><b>10.1.2</b> Constituent members selection</a></li>
<li class="chapter" data-level="10.1.3" data-path="ha.html"><a href="ha.html#end-of-the-household-generation-process"><i class="fa fa-check"></i><b>10.1.3</b> End of the household generation process</a></li>
</ul></li>
<li class="chapter" data-level="10.2" data-path="ha.html"><a href="ha.html#cross-data-individual-and-household-level-information"><i class="fa fa-check"></i><b>10.2</b> Cross data: individual and household level information</a><ul>
<li class="chapter" data-level="10.2.1" data-path="ha.html"><a href="ha.html#WithoutHHdata"><i class="fa fa-check"></i><b>10.2.1</b> Without additional household’s data</a></li>
<li class="chapter" data-level="10.2.2" data-path="ha.html"><a href="ha.html#AddData"><i class="fa fa-check"></i><b>10.2.2</b> With additional household’s data</a></li>
</ul></li>
<li class="chapter" data-level="10.3" data-path="ha.html"><a href="ha.html#chapter-summary-8"><i class="fa fa-check"></i><b>10.3</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="tresis.html"><a href="tresis.html"><i class="fa fa-check"></i><b>11</b> The TRESIS approach to spatial microsimulation</a><ul>
<li class="chapter" data-level="11.1" data-path="tresis.html"><a href="tresis.html#tresis-over"><i class="fa fa-check"></i><b>11.1</b> Overview of TRESIS modelling system</a><ul>
<li class="chapter" data-level="11.1.1" data-path="tresis.html"><a href="tresis.html#differences-between-tresis-and-other-microsimulation-systems"><i class="fa fa-check"></i><b>11.1.1</b> Differences between TRESIS and other microsimulation systems</a></li>
</ul></li>
<li class="chapter" data-level="11.2" data-path="tresis.html"><a href="tresis.html#tresis-house"><i class="fa fa-check"></i><b>11.2</b> Synthetic households</a><ul>
<li class="chapter" data-level="11.2.1" data-path="tresis.html"><a href="tresis.html#what-are-synthetic-households"><i class="fa fa-check"></i><b>11.2.1</b> What are synthetic households?</a></li>
<li class="chapter" data-level="11.2.2" data-path="tresis.html"><a href="tresis.html#required-data-for-generating-synthetic-households"><i class="fa fa-check"></i><b>11.2.2</b> Required data for generating synthetic households</a></li>
<li class="chapter" data-level="11.2.3" data-path="tresis.html"><a href="tresis.html#synthetic-households-in-r"><i class="fa fa-check"></i><b>11.2.3</b> Synthetic households in R</a></li>
</ul></li>
<li class="chapter" data-level="11.3" data-path="tresis.html"><a href="tresis.html#using-demand-models-to-allocate-synthetic-households-to-zones-using-r"><i class="fa fa-check"></i><b>11.3</b> Using demand models to allocate synthetic households to zones using R</a><ul>
<li class="chapter" data-level="11.3.1" data-path="tresis.html"><a href="tresis.html#simple-discrete-choice-model-for-residential-location"><i class="fa fa-check"></i><b>11.3.1</b> Simple discrete choice model for residential location</a></li>
<li class="chapter" data-level="11.3.2" data-path="tresis.html"><a href="tresis.html#results"><i class="fa fa-check"></i><b>11.3.2</b> Results</a></li>
</ul></li>
<li class="chapter" data-level="11.4" data-path="tresis.html"><a href="tresis.html#conclusions"><i class="fa fa-check"></i><b>11.4</b> Conclusions</a><ul>
<li class="chapter" data-level="11.4.1" data-path="tresis.html"><a href="tresis.html#limitations"><i class="fa fa-check"></i><b>11.4.1</b> Limitations</a></li>
<li class="chapter" data-level="11.4.2" data-path="tresis.html"><a href="tresis.html#metroscan-ti"><i class="fa fa-check"></i><b>11.4.2</b> MetroScan-TI</a></li>
<li class="chapter" data-level="11.4.3" data-path="tresis.html"><a href="tresis.html#extending-residential-location-to-transport-models-in-r"><i class="fa fa-check"></i><b>11.4.3</b> Extending residential location to transport models in R</a></li>
</ul></li>
<li class="chapter" data-level="11.5" data-path="tresis.html"><a href="tresis.html#chapter-summary-9"><i class="fa fa-check"></i><b>11.5</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="ABM.html"><a href="ABM.html"><i class="fa fa-check"></i><b>12</b> Spatial microsimulation for agent-based models</a><ul>
<li class="chapter" data-level="12.1" data-path="ABM.html"><a href="ABM.html#note"><i class="fa fa-check"></i><b>12.1</b> Note</a></li>
<li class="chapter" data-level="12.2" data-path="ABM.html"><a href="ABM.html#abm-software"><i class="fa fa-check"></i><b>12.2</b> ABM software</a></li>
<li class="chapter" data-level="12.3" data-path="ABM.html"><a href="ABM.html#setting-up-simpleworld-in-netlogo"><i class="fa fa-check"></i><b>12.3</b> Setting up SimpleWorld in NetLogo</a><ul>
<li class="chapter" data-level="12.3.1" data-path="ABM.html"><a href="ABM.html#graphical-user-interface-in-netlogo"><i class="fa fa-check"></i><b>12.3.1</b> Graphical User Interface in NetLogo</a></li>
</ul></li>
<li class="chapter" data-level="12.4" data-path="ABM.html"><a href="ABM.html#allocating-attributes-to-agents"><i class="fa fa-check"></i><b>12.4</b> Allocating attributes to agents</a><ul>
<li class="chapter" data-level="12.4.1" data-path="ABM.html"><a href="ABM.html#defining-variables"><i class="fa fa-check"></i><b>12.4.1</b> Defining variables</a></li>
<li class="chapter" data-level="12.4.2" data-path="ABM.html"><a href="ABM.html#reading-agent-data---option-1"><i class="fa fa-check"></i><b>12.4.2</b> Reading agent data - Option 1</a></li>
<li class="chapter" data-level="12.4.3" data-path="ABM.html"><a href="ABM.html#reading-agent-data---option-2"><i class="fa fa-check"></i><b>12.4.3</b> Reading agent data - Option 2</a></li>
</ul></li>
<li class="chapter" data-level="12.5" data-path="ABM.html"><a href="ABM.html#running-simpleworld"><i class="fa fa-check"></i><b>12.5</b> Running SimpleWorld</a><ul>
<li class="chapter" data-level="12.5.1" data-path="ABM.html"><a href="ABM.html#more-variable-definitions"><i class="fa fa-check"></i><b>12.5.1</b> More variable definitions</a></li>
<li class="chapter" data-level="12.5.2" data-path="ABM.html"><a href="ABM.html#more-setup-procedures"><i class="fa fa-check"></i><b>12.5.2</b> More setup procedures</a></li>
<li class="chapter" data-level="12.5.3" data-path="ABM.html"><a href="ABM.html#the-main-go-procedure"><i class="fa fa-check"></i><b>12.5.3</b> The main Go procedure</a></li>
<li class="chapter" data-level="12.5.4" data-path="ABM.html"><a href="ABM.html#adding-plots-to-the-model"><i class="fa fa-check"></i><b>12.5.4</b> Adding plots to the model</a></li>
<li class="chapter" data-level="12.5.5" data-path="ABM.html"><a href="ABM.html#stopping-behavior"><i class="fa fa-check"></i><b>12.5.5</b> Stopping behavior</a></li>
</ul></li>
<li class="chapter" data-level="12.6" data-path="ABM.html"><a href="ABM.html#control-the-abm-from-r"><i class="fa fa-check"></i><b>12.6</b> Control the ABM from R</a><ul>
<li class="chapter" data-level="12.6.1" data-path="ABM.html"><a href="ABM.html#running-a-single-netlogo-simulation"><i class="fa fa-check"></i><b>12.6.1</b> Running a single NetLogo simulation</a></li>
<li class="chapter" data-level="12.6.2" data-path="ABM.html"><a href="ABM.html#running-multiple-netlogo-simulations"><i class="fa fa-check"></i><b>12.6.2</b> Running multiple NetLogo simulations</a></li>
</ul></li>
<li class="chapter" data-level="12.7" data-path="ABM.html"><a href="ABM.html#chapter-summary-10"><i class="fa fa-check"></i><b>12.7</b> Chapter summary</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="apR.html"><a href="apR.html"><i class="fa fa-check"></i><b>13</b> Appendix: Getting up-to-speed with R</a><ul>
<li class="chapter" data-level="13.1" data-path="apR.html"><a href="apR.html#vector-alg"><i class="fa fa-check"></i><b>13.1</b> R understands vector algebra</a></li>
<li class="chapter" data-level="13.2" data-path="apR.html"><a href="apR.html#R-object"><i class="fa fa-check"></i><b>13.2</b> R is object orientated</a></li>
<li class="chapter" data-level="13.3" data-path="apR.html"><a href="apR.html#subsetting"><i class="fa fa-check"></i><b>13.3</b> Subsetting in R</a></li>
<li class="chapter" data-level="13.4" data-path="apR.html"><a href="apR.html#further"><i class="fa fa-check"></i><b>13.4</b> Further R resources</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="glossary.html"><a href="glossary.html"><i class="fa fa-check"></i><b>14</b> Glossary</a></li>
<li class="chapter" data-level="15" data-path="bibliography.html"><a href="bibliography.html"><i class="fa fa-check"></i><b>15</b> Bibliography</a></li>
<li class="chapter" data-level="16" data-path="spatial-microsimulation-with-r.html"><a href="spatial-microsimulation-with-r.html"><i class="fa fa-check"></i><b>16</b> Spatial Microsimulation with R</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Microsimulation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="tresis" class="section level1">
<h1><span class="header-section-number">11</span> The TRESIS approach to spatial microsimulation</h1>
<p>This chapter, by Richard Ellison and David Hensher,<a href="#fn36" class="footnoteRef" id="fnref36"><sup>36</sup></a> presents an alternative approach to spatial microsimulation that involves both the generation and simulation of individuals in household units. The method, known as TRESIS, has been developed for many years at The University of Sydney. TRESIS is mature, well tested and has been designed at the Institute of Transport and Logistics Studies (ITLS) to help solve transport-related problems.</p>
<p>This is the first published implementation of one component of TRESIS in R. It does not use a package of its own (although the development of a <strong>TRESIS</strong> package implementing the TRESIS approach in R would be possible, building on the following code). Except for <strong>dplyr</strong>, <strong>stringr</strong> and <strong>mlogit</strong> (for data manipulation, string processing and multinomial logit models, respectively), the methods are written entirely in base R. Therefore, if you understand the R language well, this chapter can also be seen as a stand-alone introduction to the TRESIS method, from a technical standpoint.</p>
<p>The chapter is divided into four sections: an overview of the method with, reference to academic research (<a href="tresis.html#tresis-over"></a>); a demonstration of the generation of realistic households used in TRESIS, building on CakeMap input data (<a href="tresis.html#tresis-house"></a>); and an illustration of how demand models can be used to allocate these synthetic households to geographic zones (Section 11.3). The work concludes with a brief discussion of the merits of the approach and directions that one could develop the methods highlighted.</p>
<div id="tresis-over" class="section level2">
<h2><span class="header-section-number">11.1</span> Overview of TRESIS modelling system</h2>
<p>TRESIS is a Transport and Environment Strategy Impact Simulator originally developed by Professor David Hensher and others at the Institute of Transport and Logistics Studies (ITLS). TRESIS evolved from an earlier project for the Bureau of Transport and Communications Economics <span class="citation">(Hensher <a href="#ref-HensherD2002">2002</a>; Hensher and Ton <a href="#ref-Hensher2002a">2002</a>)</span>. The TRESIS software provides users with the ability to assess the impacts of a large number of transport and land-use policies on various systems linked to travel behaviour. These include the environment, user expenditure and government revenue. TRESIS incorporates an extensive model system including discrete and continuous choice models. These are combined with a process of population (or more accurately, household) synthesis and a set of equilibration criteria. TRESIS provides a powerful alternative to some more widely used microsimulation implementations for evaluating strategic projects <span class="citation">(Hidas <a href="#ref-Hidas2005">2005</a>)</span>.</p>
<p>Building on the practical focus of the book, the bulk of the substantive material focusses on the generation of synthetic households, which is described in detail. The methods and code blocks outlined below are not provided as ‘production ready’ methods but stepping stones towards further transport modelling work in R. Notwithstanding recent efforts such as the <strong>stplanr</strong> package,<a href="#fn37" class="footnoteRef" id="fnref37"><sup>37</sup></a> R is currently little-used in transport research, despite its power and flexibility. The chapter demonstrates how the synthetic populations generated through TRESIS can be used to identify where different types of households live using a residential location model. The chapter concludes with discussion of other important aspects of transport modelling that could be integrated into R, building on this work.</p>
<p>Overall, the TRESIS model system was designed to cover many of the long and short-term decisions made by individuals and households that affect how they travel. These range from the very long-term (e.g., where to live and where to work) to the very short-term (e.g., departure time and travel mode). When used together, the TRESIS models predict households’ long-term decisions and how these decisions then affect how individuals within that household travel given user-specified transport and land-use policies. Although in this chapter we discuss how to implement a stand-alone residential location model, the full power of the TRESIS system is only available when the whole set of demand models is estimated and run together. The figure below shows an overview of the high level TRESIS model structure <span class="citation">(Hensher <a href="#ref-Hensher2008">2008</a>)</span>.</p>
<div class="figure"><span id="fig:unnamed-chunk-245"></span>
<img src="_main_files/figure-html/unnamed-chunk-245-1.png" alt="Overview of TRESIS model structure" width="672" />
<p class="caption">
Figure 11.1: Overview of TRESIS model structure
</p>
</div>
<p>The TRESIS demand models have been estimated from a combination of stated preference (SP) and revealed preference (RP) data using the NLOGIT software (see <span class="citation">Hensher, Rose, and Greene (<a href="#ref-Hensher2015">2015</a>)</span> for details of the software and estimation models). The model system provides for feedback between the different models using inclusive value parameters. These inclusive value parameters provide the mechanism through which the decisions made using one model (e.g., what vehicle to buy) are incorporated into the decisions made using other models in the system (e.g., where to live). In this chapter, we discuss only the stand-alone residential location model. This is just one part of TRESIS, which would be closely coupled to other sub-models covering fleet size, vehicle type choice, workplace location and dwelling type choice, among others <span class="citation">(Hensher <a href="#ref-Hensher2008">2008</a>)</span>.</p>
<div id="differences-between-tresis-and-other-microsimulation-systems" class="section level3">
<h3><span class="header-section-number">11.1.1</span> Differences between TRESIS and other microsimulation systems</h3>
<p>TRESIS differs from standard micro-simulation models in that it was designed primarily as a strategic model and in that it preserves the behavioural richness of observed individuals. In contrast, standard micro-simulation techniques commonly used in transport are largely designed for small-scale studies that cover only a small area and are typically focused on traffic simulation rather than behavioural simulation <span class="citation">(Hidas <a href="#ref-Hidas2005">2005</a>)</span>. TRESIS tends to operate at higher geographical levels than micro-simulation systems. Individuals in the household are not run through a micro-simulation model to determine specific routes. Instead, the TRESIS system estimates travel demand based on separate travel demand models within a network assignment model. Although this means that link level travel times for a specific individual cannot be determined, it provides more reliable aggregate estimates of travel time across the whole network. These are needed for the efficient running of the TRESIS models.</p>
</div>
</div>
<div id="tresis-house" class="section level2">
<h2><span class="header-section-number">11.2</span> Synthetic households</h2>
<div id="what-are-synthetic-households" class="section level3">
<h3><span class="header-section-number">11.2.1</span> What are synthetic households?</h3>
<p>Synthetic households as used in TRESIS are a combination of a set of socio-demographic characteristics and a weight that represents their incidence in the population. These synthetic households form the building blocks for TRESIS and provide the necessary underlying variables required for the models in the simulation. The households are sampled such that given certain combinations of socio-demographic variables, there is a sufficiently large variation in the sample to reasonably cover all segments of the population that are of interest.</p>
<div id="synthetic-households-in-tresis" class="section level4">
<h4><span class="header-section-number">11.2.1.1</span> Synthetic households in TRESIS</h4>
<p>There are fundamental differences between the populations generated through traditional population synthesis (described in earlier chapters) and synthetic households in TRESIS. First is that synthetic households retain their original composition and characteristics from the source sample. Rather than assigning sample individuals to households, in TRESIS individuals remain linked to their original households. Households are seen as a single entity, and used as the unit of analysis for many of the models, including the residential location model, within TRESIS. This has the side effect that each household is not simply a sum of its members but may also be considered to have its own characteristics.</p>
<p>Second is that synthetic households in TRESIS are not assigned to a unique geographic zone. Instead, the sample from which the synthetic households are drawn is limited to those households that are resident in the whole of the study area (generally a city’s Greater Metropolitan Area). This results in synthetic households having an overall geographic coverage matching the study area but no specific location within it. This approach means that the weights of the synthetic households are calculated based on their incidence in the entire population in the study area and not just their specific geographic location. The specific location of synthetic households is then assigned by running them through the TRESIS model and equilibrating the model system at trip, location and vehicle type levels. This reproduces with some accuracy the base year spatial travel and location profiles, as well as vehicle type and fleet size composition. Among others, TRESIS also includes a model for the choice of residential location using more disaggregate zones. It must be emphasised that household weights do not change when they are assigned to zones.</p>
</div>
</div>
<div id="required-data-for-generating-synthetic-households" class="section level3">
<h3><span class="header-section-number">11.2.2</span> Required data for generating synthetic households</h3>
<p>Like IPF and other population synthesis methods discussed previously, the generation of synthetic households in TRESIS requires a combination of micro level census data and aggregate population statistics.</p>
<p>The microdata needs to include matched household and individual level data. These are retained within the synthetic households. The aggregate population data should include the variables that are of most relevance to the research question for selecting synthetic households. The only <em>requirement</em> from the aggregate level data is that it includes a total count for the whole study area. The census data should ideally be available as a multi-way cross-tabulation for each combination of variables that are desired for representing the households in the target population. The reasons for this are explained further later in this chapter. For now suffice to say that the input data for TRESIS are all available from the census or other reliable sources in most advanced nations such as Australia, where the model was first developed for six of the state capital cities. The input data could come from different sources, however, if the variables are comparable.</p>
</div>
<div id="synthetic-households-in-r" class="section level3">
<h3><span class="header-section-number">11.2.3</span> Synthetic households in R</h3>
<p>Generating synthetic households in R, using the TRESIS method, requires three stages. The first involves ensuring that the variables in the micro-data sample are compatible with those used in the demand models. Where variables used in the demand models or in the aggregate population level data are derived from one (or more) of the original micro-data variables, then these variables must be defined for each of the households in the micro-data sample. The second stage involves selecting variables on which to base the synthetic households and then calculating their weights and required sample. Third, the micro-data is sampled to generate the final synthetic households each with an individual weight based on their incidence in the population.</p>
<p>For this chapter, we will use the same CakeMap dataset as was used in the previous chapter. To ensure that we are using the base data without any modifications, re-import the CakeMap data files:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ind &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/CakeMap/ind.csv&quot;</span>)
cons &lt;-<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/CakeMap/cons.csv&quot;</span>)</code></pre></div>
<p>Recall that the CakeMap dataset records individuals and not households. This means we need to add a variable to the dataset that records which household each individual is in. Since we do not know who in the CakeMap dataset is in which household, for this example we will randomly assign each individual to a household:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">99</span>) <span class="co"># This line sets the seed for the random number </span>
<span class="co"># generation in the sample() function used below. This is </span>
<span class="co"># used here to ensure that the results are consistent for each</span>
<span class="co"># run. To ensure that your weighted of synthetic variables is</span>
<span class="co"># reasonable for your application it is best to run this </span>
<span class="co"># several times without a seed and compare the results.</span>

<span class="co"># Randomly select the sizes of the households and then assign </span>
<span class="co"># the unique IDs of each household to sequential individuals </span>
<span class="co"># in the dataset.</span>
ind$hhld &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span>:<span class="dv">1000</span>, <span class="dt">times=</span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="dv">1</span>:<span class="dv">6</span>), <span class="dv">1000</span>, <span class="dt">replace=</span><span class="ot">TRUE</span>)
                )[<span class="dv">1</span>:<span class="kw">nrow</span>(ind)]

<span class="co"># Check how many households we have in our dataset:</span>
<span class="kw">length</span>(<span class="kw">unique</span>(ind$hhld))</code></pre></div>
<pre><code>## [1] 260</code></pre>
<p>Keep in mind that the sample() function randomly selects numbers so you will likely have a different number of households in your dataset unless you set the seed using <em>set.seed(99)</em> as above. Once we have assigned each individual to a dataset we can generate the household level data. For this example we can simply calculate some of these household variables including the number of individuals in the household, the number of workers and the age of the oldest person living in the household. Ensure you have loaded the <strong>dplyr</strong> and <strong>stringr</strong> packages and then run:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">library</span>(stringr)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hhlds &lt;-<span class="st"> </span><span class="kw">group_by</span>(ind, hhld) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">numres =</span> <span class="kw">n</span>(),
    <span class="co"># Values of 8 and 97 mean &quot;long-term unemployed&quot; and </span>
    <span class="co"># &quot;not answered&quot; respectively</span>
    <span class="dt">numworkers =</span> <span class="kw">length</span>(NSSEC8[NSSEC8 &lt;<span class="st"> </span><span class="dv">8</span>]),
    <span class="dt">nummanager =</span> <span class="kw">length</span>(NSSEC8[NSSEC8 ==<span class="st"> </span><span class="fl">1.1</span>]),
    <span class="dt">numprof =</span> <span class="kw">length</span>(NSSEC8[NSSEC8 ==<span class="st"> </span><span class="fl">1.2</span>]),
    <span class="dt">numrout =</span> <span class="kw">length</span>(NSSEC8[NSSEC8 ==<span class="st"> </span><span class="dv">7</span>]),
    <span class="co"># Take the midpoint of the age ranges then take the maximum</span>
    <span class="co"># for that household</span>
    <span class="dt">maxage =</span> <span class="kw">max</span>(
      <span class="kw">rowMeans</span>(
        <span class="kw">read.table</span>(
          <span class="dt">text=</span><span class="kw">str_replace</span>(ageband4, <span class="st">&#39;-&#39;</span>, <span class="st">&#39;,&#39;</span>), 
               <span class="dt">header=</span><span class="ot">FALSE</span>, <span class="dt">sep=</span><span class="st">&#39;,&#39;</span>)
        )
      ),
    <span class="co"># Value of 1 means they have a car, 2 means they do not.</span>
    <span class="co"># Divide the number of cars by 1.5 to get a more realistic</span>
    <span class="co"># number since more than 1 person can use the same car.</span>
    <span class="dt">numcars =</span> <span class="kw">floor</span>(<span class="kw">sum</span>((Car<span class="dv">-2</span>)*-<span class="dv">1</span>)/<span class="fl">1.5</span>)
  )

hhlds[,<span class="kw">c</span>(<span class="st">&quot;hhld&quot;</span>,<span class="st">&quot;numres&quot;</span>,<span class="st">&quot;numworkers&quot;</span>,<span class="st">&quot;nummanager&quot;</span>,
         <span class="st">&quot;numprof&quot;</span>,<span class="st">&quot;numrout&quot;</span>,<span class="st">&quot;numcars&quot;</span>)]</code></pre></div>
<pre><code>## # A tibble: 260 x 7
##     hhld numres numworkers nummanager numprof numrout numcars
##    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;      &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;dbl&gt;
##  1     1      4          4          0       0       1       1
##  2     2      1          1          0       0       0       0
##  3     3      5          5          0       0       0       2
##  4     4      6          5          0       0       1       3
##  5     5      4          4          0       0       2       2
##  6     6      6          5          0       0       2       2
##  7     7      5          4          1       0       1       2
##  8     8      2          2          0       0       1       1
##  9     9      3          3          0       0       1       2
## 10    10      2          2          0       0       0       0
## # ... with 250 more rows</code></pre>
<p>This code uses <strong>dplyr</strong>’s group_by() and summarise() functions to generate the household level data from the individual level data. Generally, some household level data is already provided in the micro-data sample from the census but it may be necessary to add additional summary variables using the individual level micro-data.</p>
<p>The <em>cons</em> data frame from the CakeMap dataset contains the aggregate population level data we need for generating the weights and identifying the required sample. However, since the <em>cons</em> data frame is at the Ward level, we need to aggregate to get a total for all the wards. This is easy to accomplish by using the colSums() function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">totcons &lt;-<span class="st"> </span><span class="kw">colSums</span>(cons)</code></pre></div>
<p>Now that we have finished preparing the data, we can start generating the synthetic households. Just as with selecting the constraint variables in the previous chapter, we first need to choose which variables are the most important to ensure that our synthetic households reflect the distribution of these variables in the population. We should also select the number of households we want to generate. Which variables should be used depends on exactly what is being investigated. If it is of interest to identify how a specific policy will affect households with a different number of workers (e.g., peak hour congestion charging), then it is important to ensure that the number of workers is used as one of the variables in the generation of synthetic households. For this relatively simple dataset, we will use the availability of a car and the number of professionals in the household as the weighting and sampling variables. Typically, synthetic households in TRESIS are generated using three (nested) pairs of variables including household income, number of workers, family structure (e.g., family with children, family without children, single-person household, etc) and the occupation of the reference person, among others. However, since the cross-tabs are not available for the CakeMap data, for the purposes of this example we will assume that the distributions of the two variables (car and professionals) are the same for all combinations as they are for the population. Similarly, we will assume that the distribution for households is the same for individuals.<a href="#fn38" class="footnoteRef" id="fnref38"><sup>38</sup></a></p>
<p>First, let us look at the distributions of the two variables across the population using the <em>prop.table()</em> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Car vs No Car:</span>
<span class="kw">prop.table</span>(<span class="kw">c</span>(totcons[<span class="st">&#39;Car&#39;</span>],totcons[<span class="st">&#39;NoCar&#39;</span>]))</code></pre></div>
<pre><code>##   Car NoCar 
## 0.701 0.299</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Professionals vs All others:</span>
<span class="kw">prop.table</span>(<span class="kw">c</span>(<span class="dt">Professionals=</span>totcons[<span class="st">&#39;X1.2&#39;</span>], 
             <span class="dt">OtherOcc=</span><span class="kw">sum</span>(
               totcons[<span class="kw">c</span>(<span class="kw">match</span>(<span class="st">&#39;X1.1&#39;</span>, <span class="kw">names</span>(totcons)), 
                         <span class="kw">match</span>(<span class="st">&#39;X2&#39;</span>, <span class="kw">names</span>(totcons)):<span class="kw">match</span>(
                           <span class="st">&#39;Other&#39;</span>, <span class="kw">names</span>(totcons)
                           )
                         )])))</code></pre></div>
<pre><code>## Professionals.X1.2           OtherOcc 
##             0.0595             0.9405</code></pre>
<p>The <em>prop.table()</em> function takes two or more values and generates a table with the proportion of each value is of the total. The <em>match()</em> function is used to find the elements in the vector, <em>names(totcons)</em> containing the names of the variables in the totcons data frame, that match the relevant variable name. This is used here to avoid hard coding the correct index which we may change inadvertently. Using this code we see that approximately 30% of households in the population have no car and that only 6% of the population are professionals (occupation category 1.2). Given our assumption that these distributions also apply for all combinations, we can calculate that for the population as a whole using the <em>tcrossprod()</em> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">popdistprop &lt;-<span class="st"> </span><span class="kw">tcrossprod</span>(
  <span class="kw">prop.table</span>(<span class="kw">c</span>(totcons[<span class="st">&#39;Car&#39;</span>],totcons[<span class="st">&#39;NoCar&#39;</span>])),
  <span class="kw">prop.table</span>(<span class="kw">c</span>(<span class="dt">Professionals=</span>totcons[<span class="st">&#39;X1.2&#39;</span>], 
             <span class="dt">OtherOcc=</span><span class="kw">sum</span>(
               totcons[<span class="kw">c</span>(
                 <span class="kw">match</span>(<span class="st">&#39;X1.1&#39;</span>, <span class="kw">names</span>(totcons)), 
                 <span class="kw">match</span>(<span class="st">&#39;X2&#39;</span>, <span class="kw">names</span>(totcons)):<span class="kw">match</span>(
                   <span class="st">&#39;Other&#39;</span>, <span class="kw">names</span>(totcons)
                   )
               )])))
)
<span class="kw">colnames</span>(popdistprop) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Professionals&#39;</span>,<span class="st">&#39;Other&#39;</span>)
<span class="kw">rownames</span>(popdistprop) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;Car&#39;</span>,<span class="st">&#39;NoCar&#39;</span>)
popdistprop</code></pre></div>
<pre><code>##       Professionals Other
## Car          0.0417 0.659
## NoCar        0.0178 0.281</code></pre>
<p>This code uses the <em>tcrossprod()</em> function to take the two pairs of proportions we used earlier and multiplies all values in the first matrix by each value in the second. In this case this results in a 2x2 matrix that shows the distribution for the combination of the two variables. Keep in mind that this would not need to be a square matrix if the variables used have more than two values. From this we can calculate the actual number of households in each combination. Since the CakeMap dataset includes only the number of people rather than the number of households, we will need to make the assumption that each household has a certain number of people. If we assume that each household has an average of three people living there then we would use the code below to calculate the total number of households in each group in the population as a whole. Note that if you have the actual number of households in each group, this should be used instead.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">popdisttot &lt;-<span class="st"> </span><span class="kw">round</span>(
    popdistprop*(totcons[<span class="st">&#39;Car&#39;</span>]+totcons[<span class="st">&#39;NoCar&#39;</span>])/<span class="dv">3</span>
  )
popdisttot</code></pre></div>
<pre><code>##       Professionals  Other
## Car           22577 356923
## NoCar          9624 152143</code></pre>
<p>If we choose to generate 100 synthetic households, we simply need to multiply the matrix by 100 and then round to see how many households we need to sample from each of the for combinations of variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">popdist &lt;-<span class="st"> </span><span class="kw">round</span>(popdistprop*<span class="dv">100</span>)
popdist</code></pre></div>
<pre><code>##       Professionals Other
## Car               4    66
## NoCar             2    28</code></pre>
<p>In this case, each group has at least one household in the sample. However, when more variables are used (or variables with more values), it is common for several groups to be too small to have a sufficient proportion in the population to be represented in the synthetic households (particularly with only 100 households). When this occurs, these small groups are combined into a single larger group such that together they are represented by at least one household.</p>
<p>The last step before we sample the synthetic households is to generate the weights. Similar to other other methods of population synthesis discussed earlier in this book, the weights tell us how many real households each of our synthetic households represent in the population. This is calculated by simply dividing the total number of households in each group by the number in our set of synthetic households:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">popweights &lt;-<span class="st"> </span>popdisttot/popdist</code></pre></div>
<p>You may choose to round the weights to ensure that each synthetic household represents only whole households but this is not absolutely necessary.</p>
<p>We can now sample the households with which to generate the synthetic households. Although it is possible to automate this process provided the variable names are mapped to each other, we will do this manually to illustrate the process. Taking the first group (professionals with a car) we can select the required number of households by using the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synhhlds &lt;-<span class="st"> </span><span class="kw">sample</span>(
  <span class="kw">filter</span>(
    hhlds,numprof &gt;<span class="st"> </span><span class="dv">0</span>, numcars &gt;<span class="st"> </span><span class="dv">0</span>)$hhld, 
  popdist[<span class="st">&#39;Car&#39;</span>,<span class="st">&#39;Professionals&#39;</span>]
  )
synhhldweights &lt;-<span class="st"> </span><span class="kw">rep</span>(
  popweights[<span class="st">&#39;Car&#39;</span>,<span class="st">&#39;Professionals&#39;</span>], 
  popdist[<span class="st">&#39;Car&#39;</span>,<span class="st">&#39;Professionals&#39;</span>]
  )
synhhldtypes &lt;-<span class="st"> </span><span class="kw">rep</span>(
  <span class="st">&#39;Car+Professionals&#39;</span>, 
  popdist[<span class="st">&#39;Car&#39;</span>,<span class="st">&#39;Professionals&#39;</span>]
  )</code></pre></div>
<p>The second line takes the calculated weights for that group of synthetic households and repeats it for the required number of households using the <em>rep()</em> function. The third line is used just to help identify from which group each household was sampled. This is generally not used but it can be useful for checking the results. Once we have sampled all the households we will bind the two vectors (<em>synhhlds</em> and <em>synhhldweights</em>) into a single data frame. Note that the use of the sample() function means that the specific households chosen will likely differ somewhat every time unless the <em>set.seed()</em> function is used first (as we did above). This is why it is important to select the correct variables because the only variables that are guaranteed to match the distribution in the population are those that are used to select the synthetic households. This is then repeated for each of the subsequent groups.<a href="#fn39" class="footnoteRef" id="fnref39"><sup>39</sup></a></p>
<p>This results in a vector with the household IDs of the households from the micro-data selected to be used for the synthetic households and a separate vector for the household weights. Since these two vectors are both in the same order, we can create a data frame that contains the synthetic household ID and the matching household weights.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synhhldDF &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">hhld=</span>synhhlds,
                        <span class="dt">hhldweight=</span>synhhldweights,
                        <span class="dt">hhldtype=</span>synhhldtypes
                       )</code></pre></div>
<p>Once this has been done generating the synthetic household dataset is relatively straightforward requiring us to merge the individual and household level data for our desired households. In TRESIS itself, this is followed by some additional work to ensure that any variables not required for the models are removed as well as making any necessary changes to ensure confidentiality of the micro-data is retained.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synhhlddata &lt;-<span class="st"> </span><span class="kw">merge</span>(
  <span class="kw">filter</span>(hhlds, hhld %in%<span class="st"> </span>synhhlds),
  <span class="kw">filter</span>(ind, hhld %in%<span class="st"> </span>synhhlds),
  <span class="dt">by=</span><span class="st">&#39;hhld&#39;</span>,
  <span class="dt">all.x=</span><span class="ot">TRUE</span>,
  <span class="dt">all.y=</span><span class="ot">TRUE</span>
)

<span class="co"># Merge with the weights data frame</span>
synhhlddata &lt;-<span class="st"> </span><span class="kw">merge</span>(
  synhhlddata,
  synhhldDF,
  <span class="dt">by=</span><span class="st">&#39;hhld&#39;</span>,
  <span class="dt">all.x=</span><span class="ot">TRUE</span>
)

<span class="co"># Add an ID for each individual in the household </span>
<span class="co"># (starting from 1 for each household)</span>
synhhlddata &lt;-<span class="st"> </span><span class="kw">group_by</span>(synhhlddata, hhld) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">indid =</span> <span class="dv">1</span>:<span class="kw">n</span>()
  )</code></pre></div>
<p>The <em>synhhlddata</em> data frame now contains all the data we need to use within the residential location model for assigning households to zones. So we can avoid regenerating synthetic households every time we change our residential location model, it is useful to save our data frame to an RData file:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">save</span>(synhhlddata,<span class="dt">file=</span><span class="st">&quot;output/synhhlddata.RData&quot;</span>)</code></pre></div>
</div>
</div>
<div id="using-demand-models-to-allocate-synthetic-households-to-zones-using-r" class="section level2">
<h2><span class="header-section-number">11.3</span> Using demand models to allocate synthetic households to zones using R</h2>
<p>The key to the TRESIS system are its demand models. As discussed earlier in this chapter, the models used in TRESIS include a variety of discrete choice models covering many of the travel-related decisions made by individuals and households. The models used in TRESIS are linked meaning the model for residential location cannot be completely separated out from the rest of the models. However, the TRESIS approach can be used even with a single stand-alone residential location choice model and given its (potential) simplicity, it is this approach that will be discussed here.</p>
<p>At its most basic, a residential location model as used with the TRESIS synthetic households is a discrete choice model that predicts, up to a probability, in which area each household will choose to live given their unique set of socio-demographic characteristics and the characteristics of the different zones. Although the full details of the estimation of discrete choice models is outside the scope of this book, it is worth briefly discussing how the models used for TRESIS can be estimated. The discrete choice models used for residential location in TRESIS have been estimated from disaggregate choice data collected using a combination of revealed preference and stated preference surveys. It is also possible to estimate discrete choice models using micro level data provided sufficient spatial detail is available for your purposes. The models in TRESIS were estimated using the NLOGIT software package because it provides features needed for advanced models unavailable in most other packages. However, many discrete choice models as would be used by those developing residential location models can also be estimated in R using the <strong>mlogit</strong> and <strong>mnlogit</strong> packages.</p>
<div id="simple-discrete-choice-model-for-residential-location" class="section level3">
<h3><span class="header-section-number">11.3.1</span> Simple discrete choice model for residential location</h3>
<p>The CakeMap data we are using does not have the disaggregate data we need to estimate the discrete choice model. For this reason, we will use a “model” where the parameters have been randomly selected. This means that our results in this case are unlikely to reflect the true values provided in the <em>cons</em> data frame. Nonetheless, the procedure we will use is the same as would be used if a properly estimated discrete choice model was available.</p>
<p>The discrete choice model that is needed is one where each alternative (zones in our study area) have an estimated utility function. The utility functions for each alternative can include either the same independent variables or different independent variables as well as common parameters or alternative-specific parameters. Since our dataset contains 124 wards, we will simplify our example by reducing these to 4 larger zones of 31 wards each. Zone 1 will include wards 1-31, zone 2 will include wards 32-62, etc. The model below was estimated based on using average values for each ward using a very simple model and cannot be regarded as a “good” model. However, it fits the required structure for the utility expressions and in the absence of disaggregate data for estimating the model we will use it for this example.</p>
<p><span class="math display">\[
\begin{aligned}
U_1 &amp;= \\
&amp;3.3*mgmt + 1.85*rout + 1.73*numCars \\
U_2 &amp;= \\
&amp;6.56 - 1.35*prof + 26.81*mgmt - 0.83*rout - 3.11*numCars \\
U_3 &amp;= \\
&amp;0.12 - 1.08*prof + 1.4*mgmt + 1.78*rout + 1.99*numCars \\
U_4 &amp;= \\
&amp;3.71 - 8.09*prof + 33.24*mgmt + 1.81*rout - 1.29*numCars
\end{aligned}
\]</span></p>
<p>In this model, the subscript on <em>U</em> indicates the zone, <em>mgmt</em> is the number of workers in the household who are managers, <em>prof</em> is the number of workers who are professionals, <em>rout</em> is the number of workers whose occupation is considered “route”, and <em>numCars</em> is the number of cars in the household.</p>
<p>Applying the model requires the values of each of the synthetic households to be run through the utility equations to calculate the probabilities of the households living in each of the four zones. The easiest way to calculate the utilities for each synthetic household is to make use of R’s vector functionality. Since our model includes only household level characteristics, we begin by simplifying the synthetic household data to one row per household with only the variables necessary for our model, making sure to rename them to match the variable names in our utility expressions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synrun &lt;-<span class="st"> </span><span class="kw">unique</span>(synhhlddata[,<span class="kw">c</span>(<span class="st">&quot;hhld&quot;</span>,<span class="st">&quot;nummanager&quot;</span>,<span class="st">&quot;numprof&quot;</span>,
                                <span class="st">&quot;numcars&quot;</span>,<span class="st">&quot;numrout&quot;</span>,
                                <span class="st">&quot;hhldweight&quot;</span>,<span class="st">&quot;hhldtype&quot;</span>)])
synrun &lt;-<span class="st"> </span><span class="kw">rename</span>(synrun,
                 <span class="dt">mgmt =</span> nummanager,
                 <span class="dt">prof =</span> numprof,
                 <span class="dt">numCars =</span> numcars,
                 <span class="dt">rout =</span> numrout
                 )</code></pre></div>
<p>We then create variables for each of the four utility expressions. The while loop iterates through each of the utility expressions to calculate the relevant utilities.<a href="#fn40" class="footnoteRef" id="fnref40"><sup>40</sup></a> The <em>eval()</em> and <em>parse()</em> functions are used together to take text input and evaluate the expressions as if R code had been typed into the console or a standard R script file. The <em>with()</em> function allows the variable names in the utility expressions to be used as-is, without pre-pending the data frame name and a $ to them and not attaching the data frame to the global environment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synrun &lt;-<span class="st"> </span>synrun %&gt;%<span class="st"> </span><span class="kw">mutate</span>(
  <span class="dt">u1 =</span> <span class="ot">NA</span>,
  <span class="dt">u2 =</span> <span class="ot">NA</span>,
  <span class="dt">u3 =</span> <span class="ot">NA</span>,
  <span class="dt">u4 =</span> <span class="ot">NA</span>
)
i &lt;-<span class="st"> </span><span class="dv">1</span>;
while (i &lt;=<span class="st"> </span><span class="dv">4</span>) {
  synrun[,<span class="dv">7</span>+i] &lt;-<span class="st"> </span><span class="kw">with</span>(synrun,
       <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text=</span><span class="kw">c</span>(
         <span class="st">&quot;3.2989*mgmt + 1.8519*rout + </span>
<span class="st">         1.733*numCars&quot;</span>,  
         <span class="st">&quot;6.5633 - 1.3535*prof + 26.8106*mgmt - 0.8307*rout - </span>
<span class="st">         3.1094*numCars&quot;</span>,
         <span class="st">&quot;0.115 - 1.0771*prof + 1.3984*mgmt + 1.781*rout + </span>
<span class="st">         1.9871*numCars&quot;</span>,
         <span class="st">&quot;3.7052 - 8.0874*prof + 33.2434*mgmt + 1.8073*rout - </span>
<span class="st">         1.291*numCars&quot;</span>
       )[i])))
  i &lt;-<span class="st"> </span>i +<span class="st"> </span><span class="dv">1</span>
}</code></pre></div>
<p>We can then calculate the probabilities of each synthetic household living in each zone. The equation to estimate the probabilities depend on the exact model specification that is used in the model. In this case, where the model includes alternative-specific variables (and values), we can use the equations below. These probabilities can then be used to help identify where households sharing the characteristics of each synthetic household are likely to live:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synrun &lt;-<span class="st"> </span>synrun %&gt;%<span class="st"> </span><span class="kw">mutate</span>(
  <span class="dt">p1 =</span> <span class="kw">exp</span>(u1)/(<span class="kw">exp</span>(u1)+<span class="kw">exp</span>(u2)+<span class="kw">exp</span>(u3)+<span class="kw">exp</span>(u4)),
  <span class="dt">p2 =</span> <span class="kw">exp</span>(u2)/(<span class="kw">exp</span>(u1)+<span class="kw">exp</span>(u2)+<span class="kw">exp</span>(u3)+<span class="kw">exp</span>(u4)),
  <span class="dt">p3 =</span> <span class="kw">exp</span>(u3)/(<span class="kw">exp</span>(u1)+<span class="kw">exp</span>(u2)+<span class="kw">exp</span>(u3)+<span class="kw">exp</span>(u4)),
  <span class="dt">p4 =</span> <span class="kw">exp</span>(u4)/(<span class="kw">exp</span>(u1)+<span class="kw">exp</span>(u2)+<span class="kw">exp</span>(u3)+<span class="kw">exp</span>(u4))
)</code></pre></div>
<p>The final probabilities for 10 households are shown in the table below. In this very simple example, you will see that there are some households with the same probabilities. Given a fully developed residential location model as the one used in TRESIS, with more explanatory variables as well as a wider range of grouping variables for the synthetic households, the number of households with the same probabilities would be very low. However, even from this relatively simplistic example, it is apparent that even within the same groups, the probabilities of living in a particular zone vary (sometimes substantially).</p>
<table>
<thead>
<tr class="header">
<th align="right">hhld</th>
<th align="right">hhldweight</th>
<th align="left">hhldtype</th>
<th align="right">p1</th>
<th align="right">p2</th>
<th align="right">p3</th>
<th align="right">p4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.22</td>
<td align="right">0.08</td>
<td align="right">0.29</td>
<td align="right">0.41</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.31</td>
<td align="right">0.00</td>
<td align="right">0.69</td>
<td align="right">0.00</td>
</tr>
<tr class="odd">
<td align="right">5</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.37</td>
<td align="right">0.00</td>
<td align="right">0.60</td>
<td align="right">0.03</td>
</tr>
<tr class="even">
<td align="right">6</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.37</td>
<td align="right">0.00</td>
<td align="right">0.60</td>
<td align="right">0.03</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">0.00</td>
<td align="right">1.00</td>
</tr>
<tr class="even">
<td align="right">10</td>
<td align="right">5434</td>
<td align="left">NoCar+Other</td>
<td align="right">0.00</td>
<td align="right">0.94</td>
<td align="right">0.00</td>
<td align="right">0.05</td>
</tr>
<tr class="odd">
<td align="right">13</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.10</td>
<td align="right">0.56</td>
<td align="right">0.14</td>
<td align="right">0.20</td>
</tr>
<tr class="even">
<td align="right">16</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.22</td>
<td align="right">0.08</td>
<td align="right">0.29</td>
<td align="right">0.41</td>
</tr>
<tr class="odd">
<td align="right">18</td>
<td align="right">5434</td>
<td align="left">NoCar+Other</td>
<td align="right">0.00</td>
<td align="right">0.94</td>
<td align="right">0.00</td>
<td align="right">0.05</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">5408</td>
<td align="left">Car+Other</td>
<td align="right">0.22</td>
<td align="right">0.08</td>
<td align="right">0.29</td>
<td align="right">0.41</td>
</tr>
</tbody>
</table>
</div>
<div id="results" class="section level3">
<h3><span class="header-section-number">11.3.2</span> Results</h3>
<p>The final step is to assign the number of households in each zone using the probabilities and the household weights. Although in some applications the highest probability is assumed to be the chosen zone, in the TRESIS approach, the probabilities are used in combination with the weights to identify how many real households with the same characteristics as the synthetic households would live in each zone.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">synresults &lt;-<span class="st"> </span>synrun %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(hhldtype) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">zone1 =</span> <span class="kw">round</span>(<span class="kw">sum</span>(p1*hhldweight)),
    <span class="dt">zone2 =</span> <span class="kw">round</span>(<span class="kw">sum</span>(p2*hhldweight)),
    <span class="dt">zone3 =</span> <span class="kw">round</span>(<span class="kw">sum</span>(p3*hhldweight)),
    <span class="dt">zone4 =</span> <span class="kw">round</span>(<span class="kw">sum</span>(p4*hhldweight))
  )</code></pre></div>
<p>The results of this (very basic) model are shown in the table below. These initial results do not accurately reflect the shares in the population in each zone. This is for a number of reasons. The primary reason is that the example model we used here was by many measures a poor model with very low goodness of fit, including a very low <span class="math inline">\(R^2\)</span> value and a highly insignificant <span class="math inline">\(\chi^2\)</span> p-value. If a better model had been estimated using disaggregate data, the results would be much closer to the actual population shares.</p>
<table>
<thead>
<tr class="header">
<th align="left">hhldtype</th>
<th align="right">zone1</th>
<th align="right">zone2</th>
<th align="right">zone3</th>
<th align="right">zone4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Car+Other</td>
<td align="right">77737</td>
<td align="right">38230</td>
<td align="right">137451</td>
<td align="right">103505</td>
</tr>
<tr class="even">
<td align="left">Car+Professionals</td>
<td align="right">12075</td>
<td align="right">3172</td>
<td align="right">7327</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">NoCar+Other</td>
<td align="right">524</td>
<td align="right">130409</td>
<td align="right">560</td>
<td align="right">20651</td>
</tr>
<tr class="even">
<td align="left">NoCar+Professionals</td>
<td align="right">52</td>
<td align="right">9551</td>
<td align="right">20</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>The second reason for the difference is that the model we used was not calibrated on the population shares. The TRESIS models are calibrated to ensure they reproduce the shares in the base period before being used to run any analysis. Calibration is not a straightforward process but involves adjusting the alternative-specific constants in the model until the estimated shares match the population shares within an acceptable level of tolerance.</p>
<p>Although we will not run the calibration procedure here, to illustrate the sensitivity of the results to the quality of the model and the need for calibration, we will re-run the calculations with small changes to the alternative-specific constants of the utility expressions. If we decrease the value of the alternative-specific constant of zone 2 so that the utility expressions become:</p>
<p><span class="math display">\[
\begin{aligned}
U_1 &amp;= \\
&amp;3.299*mgmt + 1.852*rout + 1.73*numCars \\
U_2 &amp;= \\
&amp;5.56 - 1.35*prof + 26.8*mgmt - 0.830*rout - 3.11*numCars \\
U_3 &amp;= \\
&amp;0.115 - 1.08*prof + 1.40*mgmt + 1.78*rout + 1.99*numCars \\
U_4 &amp;= \\
&amp;3.705 - 8.09*prof + 33.2*mgmt + 1.81*rout - 1.29*numCars
\end{aligned}
\]</span></p>
<table>
<thead>
<tr class="header">
<th align="left">hhldtype</th>
<th align="right">zone1</th>
<th align="right">zone2</th>
<th align="right">zone3</th>
<th align="right">zone4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Car+Other</td>
<td align="right">81765</td>
<td align="right">20811</td>
<td align="right">143302</td>
<td align="right">111045</td>
</tr>
<tr class="even">
<td align="left">Car+Professionals</td>
<td align="right">13107</td>
<td align="right">1633</td>
<td align="right">7833</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="left">NoCar+Other</td>
<td align="right">949</td>
<td align="right">112580</td>
<td align="right">1022</td>
<td align="right">37592</td>
</tr>
<tr class="even">
<td align="left">NoCar+Professionals</td>
<td align="right">140</td>
<td align="right">9429</td>
<td align="right">53</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>Decreasing the constant for zone 2 further results in more changes. It is important to understand that the probabilities do not change linearly in response to an equal change in the value of the alternative-specific constant. Furthermore, the switch between zones is not equal across the groups. As a result, calibration involves the incremental changes of more than one alternative-specific constant until the shares are reproduced.</p>
<p><span class="math display">\[
\begin{aligned}
U_1 &amp;= \\
&amp;3.30*mgmt + 1.85*rout + 1.73*numCars \\
U_2 &amp;= \\
&amp;4.56 - 1.35*prof + 26.8*mgmt - 0.830*rout - 3.11*numCars \\
U_3 &amp;= \\
&amp;0.115 - 1.078*prof + 1.40*mgmt + 1.78*rout + 1.99*numCars \\
U_4 &amp;= \\
&amp;3.71 - 8.09*prof + 33.2*mgmt + 1.81*rout - 1.29*numCars
\end{aligned}
\]</span></p>
<table>
<thead>
<tr class="header">
<th align="left">hhldtype</th>
<th align="right">zone1</th>
<th align="right">zone2</th>
<th align="right">zone3</th>
<th align="right">zone4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Car+Other</td>
<td align="right">84377</td>
<td align="right">9412</td>
<td align="right">147087</td>
<td align="right">116048</td>
</tr>
<tr class="even">
<td align="left">Car+Professionals</td>
<td align="right">13726</td>
<td align="right">710</td>
<td align="right">8137</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="left">NoCar+Other</td>
<td align="right">1549</td>
<td align="right">87167</td>
<td align="right">1685</td>
<td align="right">61743</td>
</tr>
<tr class="even">
<td align="left">NoCar+Professionals</td>
<td align="right">368</td>
<td align="right">9111</td>
<td align="right">141</td>
<td align="right">5</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="conclusions" class="section level2">
<h2><span class="header-section-number">11.4</span> Conclusions</h2>
<p>This chapter has described the process required for generating and applying the synthetic households used within the TRESIS model system to a more general application of population synthesis. Although TRESIS is a land-use and transport simulator, the approach described here is a generalised one that is applicable to a wide range of model systems that require, or would benefit from, the use of disaggregate data for simulating decision making involving spatial decisions including residential location but also workplace location and other activity destinations.</p>
<div id="limitations" class="section level3">
<h3><span class="header-section-number">11.4.1</span> Limitations</h3>
<p>The primary limitation of the TRESIS approach to population synthesis is its heavy reliance on detailed disaggregate household and population level data. This means that acquiring the necessary data needed for generating the synthetic households and estimating and calibrating the models is frequently a time-consuming and sometimes expensive undertaking. In many contexts such data simply does not exist.</p>
<p>However, once the data has been collected, the resulting model system is very powerful, allowing predictions not only of the current state, but also of future forecasts of decisions under uncertainty. Provided the variables on which the forecasts rely are available in the synthetic households and models and are trustworthy, the TRESIS approach provides an integrated framework for modelling transport decisions.</p>
<div id="freight-models" class="section level4">
<h4><span class="header-section-number">11.4.1.1</span> Freight models</h4>
<p>TRESIS has until recently been focused entirely on passenger transport with freight transport considered as part of the capacity of the network but not considered in the demand models. As such, the methods developed for TRESIS have been optimised for passenger transport modes. However, there is ongoing development within the Institute of Transport and Logistics Studies to develop freight and light commercial vehicle models. These models, although different in some ways to the passenger models, have been found fit in well with the concept of synthetic households. In contrast to the passenger models that rely on synthetic households, the freight and commercial vehicle models have applied the concept used for generating synthetic households, to firms resulting in the development of “synthetic firms”. Just as synthetic households are a collection of socio-demographic variables, synthetic firms are a collection of firm level (and worker) characteristics. The data requirements of synthetic households are however also problematic for synthetic firms.</p>
</div>
</div>
<div id="metroscan-ti" class="section level3">
<h3><span class="header-section-number">11.4.2</span> MetroScan-TI</h3>
<p>TRESIS, although extremely powerful in many ways, has lacked some features that are increasingly being needed for a full assessment of potential transport and infrastructure projects. MetroScan-TI is the latest evolution of the TRESIS model system that is currently being developed and incorporates all the behavioural richness of the original TRESIS models and extends this to include a much more detailed zone structure, a fully integrated network assignment model, freight models, models for firm location and modules for cost-benefit analysis and wider economy impact assessments. MetroScan-TI is intended to provide users with the ability to quickly and easily prioritise a large number of potential projects on a wide range of variables. These projects include the standard transport infrastructure (new railway lines, roads and service improvements) as well as other infrastructure and strategic level property development (the mix and number of flats, semi-detached and detached houses).</p>
</div>
<div id="extending-residential-location-to-transport-models-in-r" class="section level3">
<h3><span class="header-section-number">11.4.3</span> Extending residential location to transport models in R</h3>
<p>Residential location models are an important component of any fully integrated transport model because they provide the “productions” (i.e., demand) for travel. However, at a minimum transport models also require a method of estimating the likely destinations (or “attractions”) of trips, as well as the mode used for these trips. The TRESIS approach uses the same synthetic households, and the individuals within those households, as were used in this chapter for the residential location model, to estimate the destinations and modes of trips. This means the development of a full transport model in R can apply the synthetic household method described in this chapter. Although developing the full set of models cannot be described as a simple process, as demonstrated in this chapter, the functionality of R, and some of its packages, makes it well suited to applying transport models. In particular, implementing full network assignment in R is likely to be particularly challenging, but its data structures and rapidly improving GIS functionality, some of which has been demonstrated in this chapter, means these are also likely to be possible.</p>
</div>
</div>
<div id="chapter-summary-9" class="section level2">
<h2><span class="header-section-number">11.5</span> Chapter summary</h2>
<p>This chapter has provided an introduction to the TRESIS approach to population synthesis through the use of synthetic households and demand models. In it we learned to generate, allocate and model household level data. TRESIS is an approach that is relatively simply conceptually but that incorporates powerful behavioural features. This, combined with its ability to model a wide range of phenomena and behaviours in the synthetic households, makes TRESIS well suited to implementation in R (subject to data requirements). It can also be applied to a variety of other applications not limited to those involving transport models.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-HensherD2002">
<p>Hensher, David A. 2002. “A Systematic Assessment of the Environmental Impacts of Transport Policy.” <em>Environmental and Resource Economics</em> 22 (1). Springer: 185–217. <a href="http://www.springerlink.com/index/FJHH830P34VQBANM.pdf" class="uri">http://www.springerlink.com/index/FJHH830P34VQBANM.pdf</a>.</p>
</div>
<div id="ref-Hensher2002a">
<p>Hensher, David A, and Tu Ton. 2002. “TRESIS: A transportation, land use and environmental strategy impact simulator for urban areas.” <em>Transportation</em> 29 (4). Springer: 439–57.</p>
</div>
<div id="ref-Hidas2005">
<p>Hidas, Peter. 2005. “A functional evaluation of the AIMSUN, PARAMICS and VISSIM microsimulation models.” <em>Road &amp; Transport Research</em> 14 (4): 45–59.</p>
</div>
<div id="ref-Hensher2008">
<p>Hensher, David A. 2008. “Climate change, enhanced greenhouse gas emissions and passenger transport - What can we do to make a difference?” <em>Transportation Research Part D: Transport and Environment</em> 13 (2): 95–111. doi:<a href="https://doi.org/10.1016/j.trd.2007.12.003">10.1016/j.trd.2007.12.003</a>.</p>
</div>
<div id="ref-Hensher2015">
<p>Hensher, David A, John M Rose, and William H Greene. 2015. <em>Applied Choice Analysis</em>. Second Edi. Cambridge: Cambridge University Press.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="36">
<li id="fn36"><p>Richard B. Ellison and David A. Hensher are based at Institute of Transport and Logistics Studies, The University of Sydney Business School, The University of Sydney.<a href="tresis.html#fnref36">↩</a></p></li>
<li id="fn37"><p>See <a href="https://github.com/ropensci/stplanr" class="uri">https://github.com/ropensci/stplanr</a> for more information.<a href="tresis.html#fnref37">↩</a></p></li>
<li id="fn38"><p>This will generally not be the case in reality and so every effort should be made to source multi-way cross tab data for the required variables.<a href="tresis.html#fnref38">↩</a></p></li>
<li id="fn39"><p>The code for this stage is over 50 lines long so is not included in the book. See the <a href="https://github.com/Robinlovelace/spatial-microsim-book/blob/master/11-Tresis_chapter.Rmd">online version</a> of the chapter of <a href="http://git.io/vGAEz" class="uri">http://git.io/vGAEz</a> for the code.<a href="tresis.html#fnref39">↩</a></p></li>
<li id="fn40"><p>It is possible to extract the coefficients and variables names directly from the output of mlogit if desired. The text format is shown here since models estimated using nlogit are generally written in this format.<a href="tresis.html#fnref40">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="ha.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="ABM.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
